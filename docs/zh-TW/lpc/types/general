型態用於四種地方:

  宣告全域變數的型態.
  宣告函式的型態.
  宣告函式參數的型態.
  宣告函式裡面的區域變數型態 

普通情況下, 可以完全忽略型態的資料, 把它當作是程式的說明. 例外的情況是驅
動程式對程式最佳化 (optimization) 時, 如果宣告 x  為 int (整數) 變數, 則
將 x + 0  視為與 x  相同. 但是 x  宣告為 string (字串)  變數時, 結果就不
可能與前面一樣. 當一個函數的基本型態已經宣告時, 會在函式內部強迫加上一個
較嚴格的型態檢查 (strict type checking) . #pragma strict_types  強迫函數
必須有傳回值 (return value),  所以無法避免函式內部的嚴格型態檢查. 這樣表
示, 一定要定義所有參數的型態, 而變數只能儲存其宣告型態的值. call_other()
函式定義為傳回 unknown (未知) 型態值, 因為驅動程式不可能知道傳回值得型態
. 如果定義了 CAST_CALL_OTHERS,  就必須指定傳回值, 結果就假設其型態為
mixed  (混合) . 指定 (cast) 傳回值型態, 可以將型態名稱放在 ( ) (小括號)
裡面. 這樣子指定型態沒有什麼實際效果, 只是安慰編譯器而已.

範例如下, 詢問一個物件的簡稱: 
 
  (string)call_other(ob, "short");
  ...或...
  (string)ob->short();

當一個函式以嚴格型態檢查時, 只能呼叫其他已經定義的函式. 如果函式尚未定義,
就必須事先用函式原型 (prototype)  使目前的函式能呼叫它們.

函式原型的例子: 
 
  string func(int arg);

注意, ;  (分號) 代替了函式的內容. 所有的參數可以指定名稱, 卻不見得要跟實
際的函式參數同名. 也可以不寫參數的名字:

  string func(int);
 
型態有兩種分類: 基本型態和特殊型態. 一個變數或函式最多只能指定一種基本型
態, 卻可以指定許多特殊型態.

只有編譯器用得到嚴格型態檢查, 執行時段 (runtime)  則不用. 所以實際上, 就
算使用嚴格型態檢查, 也可以在一個字串變數裡, 放上一個數字.

為什麼要使用嚴格型態檢查 ?  我們還是建議您用它, 因為編譯器會在編譯程式時
找出錯誤而省下許多除錯的時間. 通常在執行時段中追蹤一個錯誤是很困難的.

基本型態分為兩組. 分別為存取變數值 (value)  及存取位址 (address). int,
string, float 屬於存取變數值的型態. 而 mapping, function, object, pointer
(前面有 * 號的型態) 屬於位址. 如果把位址型態的值指定給一個變數, 或當作參
數, 它們會指向真正的資料所在. 也就是說, 如果改變一個陣列的元素值, 則所有
指向此陣列的變數指標也會一起改變. 但是要改變一個陣列的大小, 一定要重新配
置 (allocate) 一個新的陣列. 比較運算子 (comparison operator)「==」對於前
述的存取變數值一組的型態, 會比較其真正的值. 但是對於 array, mapping 等等
, 只會檢查兩者是否是相同的陣列、映射等等. 在此有一個很重要的提示是, 運算
式: ({ 1 }) == ({ 1 })  會產生偽值 (false), 因為使用 ({ ... })  這一對陣
列構造運算子 (array construction operator-pair) , 會產生新的陣列.
 
基本型態
 
int (整數)
  整數 (32 bit).
 
float (浮點數)
  浮點數 (32 bit).
 
string (字串)
  無限 (unlimited)  的字元字串 (沒有「\0」).
 
object (物件)
  一個物件指標.
 
mapping (映射)
  一種聯結 (associative)  陣列的形式; 請參考其他文件.
 
function (函式指標)
  一種特殊的型態, 以某種方式指向一個函式; 請參考其他文件.
 
Arrays (陣列)
  在一個基本型態前面加上 *  號以宣告陣列. 譬如說, 宣告一個整數陣列:
  int *arr; . 如果您想宣告一個陣列的陣列 (譯按: 即二元陣列) , 要使用
  mixed  (混合) 型態, 或是 mixed  與其他型態的組合.
 
void (無傳回值)
  這種型態只能用於函式. 它代表函式沒有任何傳回值. 如果此函式有傳回值 (有
  型態檢查時) , 編譯器就會抱怨.
 
mixed (混合)
  此種型態很特殊, 這種型態可以使用任何型態的內容. 所以任何宣告為 mixed 
   (混合) 型態的變數、函式、參數, 都不會引起編譯器的抱怨. 但是混合型態的
  目的並不在此. 只有在一個變數真正包括不同的內容型態時, 才適於使用混合型
  態. 請儘量避免使用此種型態, 因為讓一個函式傳回不同型態的值, 是不好的程
  式寫法.
 
特殊型態

有一些特殊型態, 可以加在基本型態之前. 這些特殊型態可以互相組合. 在一個繼
承敘述 (inherit statement)  之前指定某個特殊型態, 則繼承而來的型態也會與
這個特殊型態合併. 唯一的例外是 public  (公共) 型態, 不可以再以 private繼
承敘述定義為 private 型態.
 
varargs (不定參數)
  這種型態的函式可以傳入不定數目的參數. 不是此型態的函式, 則會檢查參數的
  個數, 如果數目不符會產生錯誤.
 
private (私有)
  可以用於函式和變數. 一個物件中的 private  函式, 無法經由 call_other()
  被其他物件呼叫之. 而繼承此物件的其他物件也無法使用此函式.
 
static (靜態)
  這種特殊型態讓變數和函式的行為變得不太一樣. 對函式來說, 其效果類似於
  private,  其他物件也無法利用 call_other() 呼叫此函式. static  變數則
  無法使用 save_object()  儲存, 或 restore_object() 載入其值.

public (公共)
  定義為 public 型態的函式都能被其他物件呼叫, 甚至是繼承而來的 private
  函式也可以定義為 public.
 
nomask (不可遮蓋)
  任何定義為 nomask 的函式或變數, 都不能經由繼承再次重新定義. 但是可以
  依原來的定義使用之. nomask  也阻止函式被 shadow() 投影.

翻譯:	Spock @ FF	97.Aug.11.
