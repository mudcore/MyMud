LPC 的 inherit 敘述:

語法: inherit 路徑名稱;

路徑名稱前後必須加上雙引號 " ,  例如 "/std/object".

inherit 敘述提供 LPC  物件繼承的能力 (從物件導向程式設計而來的觀念).  繼
承性 (inheritance)  讓物件能繼承其他物件的函式和變數. 因為 MudOS  驅動程
式將全域資料 (global data)  儲存於內部, 並且將不同物件的程式碼分開編譯
(compile) , 所以許多不同的物件可以用繼承能力分享同一段編譯程式碼. 每一個
物件會將任何全域變數再自己拷貝一份. 假設分別有兩個物件 A  與 B  繼承物件
C , 重新編譯 A  或 B  不會使 C  也重新編譯一次. 但是, 這樣會讓 A  或 B  
失去由 C  提供的全域變數值﹝記住, A 和 B  都有一份 C  提供之全域變數的拷
貝. 所以更新 (update) A 不會影響 B  的全域變數 ( C  提供的) , 反之亦然﹞. 

假設物件 A  繼承物件 B. 物件 A  可以定義與 B  裡面有相同名稱的變數和函式.
如果 A  定義了一個與 B  中同名的函式, 則 A  定義的函式就外部 (override)
B 的函式定義. 如果 A  想使用 B  的定義, 可以這樣做: 假設 A  定義了一個名
為 query_long 的函式, 而 A  又想呼叫 /std/object.c  物件中的 query_long
函式, 則 A  可以使用 object::query_long() 來呼叫. 如果 A  定義了與 B  中
同名的全域變數, 則 A  只能藉由呼叫 B  的函式以取得或操作 B  的同名全域變
數. 如果 B  定義的一個全域變數, 在 A  中並沒有宣告 (declare)  過, 則 A  
可以使用這個全域變數, 就像是 A  自己的全域變數一樣 (假設 B  沒有限制其他
物件是否能存取此全域變數) 注意: 如果重新編譯物件 B, A 會一直使用舊的 B
物件, 直到物件 A  也重新編譯一次. 

您可以多重繼承. 多重繼承就是一個物件可以繼承一個以上的物件. 假設 special.c
繼承 weapon.c 和 armor.c, 而 weapon.c 和 armor.c  都提供了自己的
query_long()  函式. 讓我們假設 special.c  有時候想當成一樣武器, 而有時候
想當作一個護甲. 當 special.c  看來像是護甲時, 可以用 armor::query_long()
, 而看來像武器時, 就用 armor::query_long().

請參考 types/modifiers  此份文件, 說明被繼承的物件可以對繼承它的物件隱藏
資料和函式定義.

翻譯:	Spock @ FF	97.Aug.10.
