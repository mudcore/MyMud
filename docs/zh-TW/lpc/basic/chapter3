				基礎 LPC
			作者: Descartes of Borg
			第一版: 23 april 1993
			第二版: 17 june 1993

第三章: LPC  的資料型態 (data type)

3.1 你現在該知道的事

LPC 物件由零個或多個變數組合而成, 而這些變數由一個或多個函式組合而成. 
在程式碼中, 這些函式的先後順序是無關緊要的. 當你寫的 LPC  第一次被參考
時, driver  把它複製一份到記憶體中. 之後, 還可藉此複製出更多相同的拷貝. 
任何一份物件被載入記憶體時, 所有的變數一開始都指向「虛無值」. 精簡模式
mud 的 reset()  函式與原始模式的 create() 函式都都用於指定物件的初始變
數值. 物件載入記憶體之後, 會立刻呼叫創造的函式. 不過, 如果你讀這份課本
之前沒有寫過程式, 你大概不知道什麼是函式 (function) , 或函式是怎麼被呼
叫的. 就算你以前寫過程式, 你大概也想知道新創造的物件中, 函式之間互相呼
叫對方的過程是什麼. 回答以上這些問題以前, 你得多了解函式在處理什麼. 所
以你應該先徹底了解 LPC  資料型態背後的觀念. 說實在的, 在這份手冊裡頭最
無聊的主題, 也是最重要的主題, 90% 以上就是用錯 LPC  資料型態 (放錯 {}
和 () 不算在內).  所以說, 你得要耐心看完非常重要的這一章, 因為我覺得你
如果搞懂這一章, 可以讓你以後寫程式大大輕鬆不少.

3.2 與電腦溝通

你應該已經知道電腦不懂人類所使用的單字與數字. 電腦所說的「語言」由 0 
與 1  的「字母」所組合而成. 當然, 你知道電腦不懂人類的自然語言. 但是實
際上, 它們也不懂我們寫給它們的電腦語言. 像是 BASIC、C、C++、Pascal 等等
, 這些電腦語言全都是過渡語言. 這些電腦語言讓你能把想法組織起來, 讓思考
更易轉換成電腦的 0  與 1  語言.

轉換有兩個方法: 編譯 (compilation)  和直譯 (interpretation) . 這兩個方
法的差別在於程式語言轉換成真正電腦語言的時候. 對編譯的程式語言來說, 程
式設計者撰寫程式碼之後, 使用編譯程式 (compiler) 把程式碼轉換成電腦真正
的語言. 程式在執行之前就已經轉換完畢. 而直譯的程式語言, 在程式執行的時
候才開始轉換. 因此直譯的程式語言所寫的程式執行起來要比編譯的慢上許多.

總而言之, 不管你用什麼程式語言撰寫程式, 最後都要轉變成 0  與 1  才能讓
電腦搞懂. 但是你儲存在記憶體中的變數並不是單純的 0  與 1. 所以你用的程
式語言要有個方法告訴電腦, 這些 0  和 1  到底要當作十進位數字、字元
 (characters) 、字串 (string) 、還是當作其他的東西看待. 你可以靠著指定
資料型態來辦到.

舉例來說, 假設你有個變數叫做 x ,  而你給它一個十進位的值 ── 65. 在
LPC 裡面, 你會寫出下面的敘述:

-----
x = 65;
-----

你等一下再做像這樣的事:

_____
write(x+"\n");        /* \n 符號代表在此換行 (carriage return) */
y = x + 5;
-----

第一行讓你送出 65 和換行到某個人的螢幕上. 第二行讓你把 y  設定為 70.  
問題是你告訴電腦 x = 65; 時,  它不知道 65 到底是啥意思. 你認為是 65,  
對電腦來說也許認為是:
00000000000000000000000001000001
而且, 對電腦來說, A 這個字母就是:
00000000000000000000000001000001
所以, 不管你什麼時候告訴電腦 write(x+"\n");,  電腦總要有個方法知道你想
看到 65 而不是 A.

電腦能透過資料型態了解 65 與 A  的不同. 資料型態只是說記憶體位置中儲存
的指定變數到底是屬於什麼型態的資料. 所以說, 每一個 LPC  變數都有變數型
態指導如何轉換資料. 在上面的範例裡, 你應該會在程式碼「之前」加上以下這
行:

-----
int x;
-----

這一行告訴 driver 無論 x  指向何處, 都當作「int」 資料型態來使用. int 
是整數 (interger, 或稱 whole number)  的縮寫. 現在我們已經初步介紹為什
麼要有資料型態. 這樣一來, driver  才能搞清楚電腦儲存在記憶體中的 0  與
1 到底是代表什麼意義. 

3.3 LPC 的資料型態

所有的 LPMud driver 都有以下的資料型態:

void (無), status  (狀況), int (整數), string  (字串), object  (物件), 
int *  (整數指標), string *  (字串指標), object *  (物件指標), 
mixed * (混合指標)

很多種 driver  (不是全部) 有下列資料型態值得討論:

float  (浮點數), mapping  (映射), float *  (浮點數指標), 
mapping * (映射指標)

少數 driver 有下列罕用的資料型態, 並不值得討論:

function (函式), enum, struct  (結構), char  (字元)

 (譯註: 目前台灣絕大多數的 LPMud  所使用的 driver 是 MudOS, 其資料型態
有些許不同之處. 請詳見參考譯者所翻譯之 MudOS  參考文件)

3.4 簡單的資料型態

這份簡介性質的課本會介紹 void, status, int, float, string, object, 
mixed 這幾種資料型態. 你可以在中階課本 (intermediate book,  譯註: 本作
者另外有寫一份中階 LPC  手冊, 譯者亦有翻譯) 找到像是 mapping (映射) 或
array (陣列)  這種更複雜的資料型態. 本章先介紹兩種最簡單的資料型態 (以
LPC 程式設計者的觀點來看)  ── 整數 (int)  和字串 (string).

int 表示任何整數. 所以 1, 42, -17, 0, -10000023 都是整數 (int)  型態. 
string  是一個以上的字元或數字. 所以 "a", "we are borg", "42", 
"This is a string"  都是字串. 請注意, 字串前後都要加上雙引號 "" , 
driver  才能分辨 int 42 和 string "42". 也才能區別變數名稱 (像是 x )  
與字串 (像是 "x" ).

當你在程式碼中使用變數, 你一開始要讓 driver 知道這個變數所指的是哪種變
數型態. 這種處理方式叫做「宣告」 (declaration). 你得在函式一開始的地方
宣告, 或是在物件程式碼的開頭之處 (在函式之外, 任何函式用到該變數之前).
要宣告變數型態的話, 只要像底下一樣, 把變數型態擺在變數的名字前便即可.

-----
void add_two_and_two() {
    int x;
    int y;

    x = 2;
    y = x + x;
}
-----

像這樣, 這是一個完整的函式. 函式的名稱是 add_two_and_two(). 函式一開始
宣告一個整數變數 x, 之後宣告一個整數變數 y. 所以, 在這裡 driver 有兩個
變數指向 NULL  (虛無) 值, 而這兩個變數期待的變數值是整數型態.

關於虛無 (void) 和狀態 (status) 資料型態:

無 (void) 是一種很普遍的資料型態, 它不指向任何東西. 它並不是用在變數上面的
型態, 而是用於函式. 你稍後會了解這裡所說的事. 而現在, 你只需要知道 void
不指向任何值.

狀況 (status) 資料型態是布林 (boolean)  資料型態. 就是說, 它的值是 0  
或 1. 這種值常常稱為真 (true) 或偽 (false).

3.5 本章總結

對變數來說, driver  需要知道電腦儲存在記憶體中的 0  與 1  要如何轉換成
你想使用的形式. 最簡單的 LPC  資料型態是 void, status, int, string. 變
數不使用 void 的資料型態, 但是這種資料型態用於函式. 另外, 資料型態用於
轉換格式, 決定 driver 應該使用哪種規則處理運算, 像是 +, - ......以此類
推. 舉例說, 運算式 (expression) 5+5, driver 知道 5  加上 5  的值是 10.
對字串來說, 對字串使用整數加法沒有意義. 所以, "a"+"b" 把 "b"  加在 "a"
的後面, 最後得出 "ab". 當你試著把 "5"+5 就會產生錯誤. 因為把整數加上字
串是無意義的, 所以 driver 會把第二個 5  轉換成 "5"  再加起來. 最後的結
果是 "55".  如果你想看的結果是 10 , 你最後只得到錯誤的程式碼. 請記住,
大多數的情況下, driver  不會像前面這樣產生 "55" 這種有用的結果. 它會產
生 "55" 是因為它早有一條規則處理整數加上字串的情況, 也就是把整數當成字
串看待. 在大多數的狀況中, 如果你在運算式或函式中使用資料型態並沒有事先
定義 (像是你試著把 "this is"  除以 "nonsense", "this is" / "nonsense")
, driver  會嘔吐並回報錯誤給你.

翻譯:
	Spock of Final Frontier		98.Jan.22.
